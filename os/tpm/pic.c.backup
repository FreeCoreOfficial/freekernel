// kernel/drivers/pic.c
#include <stdint.h>
#include "../arch/i386/io.h"
#include "pic.h"

/* PIC ports */
#define PIC1_CMD  0x20
#define PIC1_DATA 0x21
#define PIC2_CMD  0xA0
#define PIC2_DATA 0xA1

/* Initialization Control Words */
#define ICW1_INIT     0x10
#define ICW1_ICW4     0x01
#define ICW4_8086     0x01

/* Remap PIC to vectors 0x20-0x2F (IRQ0..IRQ15 -> INT32..INT47) */
void pic_remap(void)
{
    /* Save masks */
    uint8_t a1 = inb(PIC1_DATA);
    uint8_t a2 = inb(PIC2_DATA);

    /* Start initialization */
    outb(PIC1_CMD, ICW1_INIT | ICW1_ICW4);
    outb(PIC2_CMD, ICW1_INIT | ICW1_ICW4);

    /* Set vector offset */
    outb(PIC1_DATA, 0x20); /* Master PIC vector offset = 32 */
    outb(PIC2_DATA, 0x28); /* Slave PIC vector offset  = 40 */

    /* Tell Master about slave at IRQ2 (0000 0100) */
    outb(PIC1_DATA, 0x04);
    /* Tell Slave its cascade identity (0000 0010) */
    outb(PIC2_DATA, 0x02);

    /* Set 8086 mode */
    outb(PIC1_DATA, ICW4_8086);
    outb(PIC2_DATA, ICW4_8086);

    /* Restore saved masks */
    outb(PIC1_DATA, a1);
    outb(PIC2_DATA, a2);
}

/* Send End Of Interrupt for given IRQ (0..15) */
void pic_send_eoi(uint8_t irq)
{
    /* If the IRQ was from the slave PIC, we must ack the slave first */
    if (irq >= 8) {
        outb(PIC2_CMD, 0x20);
    }
    /* Always ack the master */
    outb(PIC1_CMD, 0x20);
}
